"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  initializeHealth: true,
  isAvailable: true,
  read: true,
  write: true
};
exports.write = exports.read = exports.isAvailable = exports.initializeHealth = void 0;
var _reactNative = require("react-native");
var _reactNativeHealthConnect = require("react-native-health-connect");
var _dataTypes = require("./types/dataTypes.js");
Object.keys(_dataTypes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _dataTypes[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dataTypes[key];
    }
  });
});
var _save = require("./helpers/save.js");
var _results = require("./helpers/results.js");
var _permissions = require("./helpers/permissions.js");
var _units = require("./types/units.js");
Object.keys(_units).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _units[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _units[key];
    }
  });
});
var _save2 = require("./types/save.js");
Object.keys(_save2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _save2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _save2[key];
    }
  });
});
var _permissions2 = require("./types/permissions.js");
Object.keys(_permissions2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _permissions2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _permissions2[key];
    }
  });
});
const AppleHealthKit = require('react-native-health');

/**
 * Initializes the health integration for the application by requesting the necessary permissions
 * based on the platform (iOS or Android).
 *
 * @param {HealthPermissions} permissions - The permissions required for accessing health data.
 *
 * @returns {Promise<void>} A promise that resolves when the initialization and permission request process is complete.
 *
 * @example
 * ```typescript
 * const permissions = {
 *   read: [HealthLinkPermissions.StepCount, HealthLinkPermissions.HeartRate],
 *   write: [HealthLinkPermissions.StepCount]
 * };
 * await initializeHealth(permissions);
 * ```
 */
const initializeHealth = async permissions => {
  if (_reactNative.Platform.OS === 'ios') {
    const iosPermissions = (0, _permissions.genericToIosPermissions)(permissions);
    AppleHealthKit.initHealthKit(iosPermissions, error => {
      console.error(error);
    });
  } else if (_reactNative.Platform.OS === 'android') {
    const androidPermissions = (0, _permissions.genericToAndroidPermissions)(permissions);
    await (0, _reactNativeHealthConnect.initialize)();
    await (0, _reactNativeHealthConnect.requestPermission)(androidPermissions);
  }
};

/**
 * Checks the availability of the SDK on the current platform.
 *
 * On Android, it checks the SDK status and resolves to `true` if the SDK is available,
 * otherwise logs the reason for unavailability and resolves to `false`.
 *
 * On iOS, it uses AppleHealthKit to check availability and resolves to the result.
 *
 * @returns {Promise<boolean>} A promise that resolves to `true` if the SDK is available, otherwise `false`.
 *
 * @example
 * isAvailable().then((available) => {
 *   if (available) {
 *     console.log('SDK is available');
 *   } else {
 *     console.log('SDK is not available');
 *   }
 * }).catch((error) => {
 *   console.error('Error checking SDK availability:', error);
 * });
 */
exports.initializeHealth = initializeHealth;
const isAvailable = () => {
  return new Promise(async (resolve, reject) => {
    if (_reactNative.Platform.OS === 'android') {
      const status = await (0, _reactNativeHealthConnect.getSdkStatus)();
      if (status === _reactNativeHealthConnect.SdkAvailabilityStatus.SDK_AVAILABLE) {
        resolve(true);
      } else {
        if (status === _reactNativeHealthConnect.SdkAvailabilityStatus.SDK_UNAVAILABLE) {
          console.log('SDK is not available');
        }
        if (status === _reactNativeHealthConnect.SdkAvailabilityStatus.SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED) {
          console.log('SDK is not available, provider update required');
        }
        resolve(false);
      }
    } else if (_reactNative.Platform.OS === 'ios') {
      AppleHealthKit.isAvailable((err, available) => {
        if (err) {
          console.error('Error checking availability: ', err);
          reject(err);
        } else {
          resolve(available);
        }
      });
    }
  });
};

/**
 * Reads health data of the specified type from the device.
 *
 * @param {T} dataType - The type of health data to read. Use the `HealthLinkDataType` enum.
 * @param {ReadOptions} options - The options for reading the health data.
 * @returns {Promise<Array<HealthLinkDataValue<T>>>} A promise that resolves to an array of health data values.
 */
exports.isAvailable = isAvailable;
const read = async (dataType, options) => {
  let data = [];
  if (_reactNative.Platform.OS === 'ios') {
    data = await (0, _results.readIosCallback)(dataType, options);
  } else if (_reactNative.Platform.OS === 'android') {
    data = await (0, _reactNativeHealthConnect.readRecords)(dataType, (0, _dataTypes.optionsToAndroidOptions)(options));
  }
  return (0, _results.readDataResultDeserializer)(dataType, options, data);
};

/**
 * Writes health data to the appropriate platform's health store.
 *
 * @param {T} dataType - The type of data to be written, extending WriteDataType.
 * @param {WriteOptions<T>} data - The data to be written.
 * @returns {Promise<void>} A promise that resolves when the data has been written.
 *
 * @example
 * ```typescript
 * const dataType = 'heartRate';
 * const data = { value: 72, timestamp: new Date() };
 * await write(dataType, data);
 * ```
 */
exports.read = read;
const write = async (dataType, data) => {
  const serializedData = (0, _save.serializeWriteOptions)(dataType, data);
  if (serializedData === null) {
    return;
  }
  if (_reactNative.Platform.OS === 'ios') {
    await (0, _save.writeIosCallback)(dataType, serializedData);
  } else if (_reactNative.Platform.OS === 'android') {
    await (0, _reactNativeHealthConnect.insertRecords)([serializedData]).catch(e => {
      console.error(e);
    });
  }
};
exports.write = write;
//# sourceMappingURL=index.js.map